\section{THOR Inputs}\label{sec:THOR_format}

The THOR transport solver has distinct user input formats for the following separate input files:
\begin{itemize}
    \item Standard Input (Sec.~\ref{ch:inp:sec:stdinput}) - The primary input file to be run by THOR.
    All other input files will either be listed in this file, or assumed to be the default filenames as described in Section~\ref{ch:inp:sec:stdinput}.
    This is the only input file given to THOR by way of the command line.
    \item Mesh File (Sec.~\ref{ch:inp:sec:meshfile}) - File containing the physical 1st order tet mesh for the problem.
    \item Cross Section File (Sec.~\ref{ch:inp:sec:xsfile}) - File containing cross sections for the problem.
    \item Density Factor File (Sec.~\ref{ch:inp:sec:densfact}) - File containing the density factors for each adjustment of cross sections in each region.
    \item Initial Guess File (Sec.~\ref{ch:inp:sec:initguess}) - File containing the initial guess for the problem.
    \item Source File (Sec.~\ref{ch:inp:sec:srcfile}) - File containing the source for a fixed source problem.
    \item Inflow File (Sec.~\ref{ch:inp:sec:inflow}) - File containing the boundary condition inflow data for a fixed source problem.
\end{itemize}

This chapter describes the input formats of the THOR transport solver.

\section{Standard Input}\label{ch:inp:sec:stdinput}

The following describes properties of the keyword based THOR input file:
\begin{itemize}
  \item Any keyword can appear in any order, but no keyword may appear multiple times.
  \item Every keyword has a default value, and THOR will echo a verbose form of the input at the beginning of the run, including all keywords and their values for the problem, whether they are set by the user or not.
  \item Whitespace is necessary between a parameter and the parameter values but is otherwise ignored.
  \item It is recommended that each parameter have its own line, however multiple parameters can be on the same line separated by semicolons (;).
  \item The user should ensure that line endings are UNIX text line endings, not Windows or Mac line endings.
  \item Whether multiple parameters are on the same line or not, the value immediately following the parameter is assumed to be that parameter's value.
  \item A line cannot contain more than 200 characters and most parameters must have all their values on the same line they reside, with exceptions outlined in the parameter descriptions, for some parameters that have a potentially large number of values.
  \item Lines starting with an exclamation point, !, and blank lines will be ignored. Any data following an exclamation point on a used line will be ignored. This is equivalent to FORTRAN's comment style.
\end{itemize}

\subsection{TYPE Card}

\begin{verbatim}
  type [<keig|fsrc>]
\end{verbatim}

\begin{tabular}{|l | l | l | l|}
\hline
Keyword & Type & Options & Default \\ \hline
\verb"type" & String & keig/fsrc & fsrc \\ \hline
\multicolumn{4}{|l|}{Description: }\\
\hline
\end{tabular}

\begin{longtable}[H]{l l l l}
    \toprule
    Keyword & Type & Options & Explanation\\
    \midrule
        &    &   & Problem type. Either eigenvalue (keig) or fixed source (fsrc) \\ \hline
    \verb"keigsolver" & String & pi / jfnk  & Solve type for keig. Either power iteration (pi) or Jacobian-Free Newton-Krylov (jfmk) \\ \hline
    \verb"lambda" & Integer & - & Expansion order, negative number indicates reduced set \\ \hline
    \verb"inflow" & String  & yes / no & If fixed inflow boundary conditions are provided for fsrc problems\\ \hline
    \verb"piacc" & String & errmode / none & Type of power iteration acceleration: none or error mode extrapolation \\ \hline
    \verb"page_sweep" & String & yes / no & If the sweep path is saved or is paged to scratch file when not needed\\ \hline
    \verb"page_refl" & String & page / save / inner & If significant angular fluxes are paged to/from scratch file (page), stored (save), or discarded after completing inner iterations for a given group\\ \hline
    \verb"page_iflw" & String  & bygroup / all & If inflow information is loaded to memory completely (all) or for each group when required (bygroup)\\ \hline
    \verb"kconv" & Real & - & Stopping criterion for eigenvalue\\ \hline
    \verb"innerconv" & Real & - & Stopping criterion for group flux during inner iteration \\ \hline
    \verb"outerconv" & Real & - & Stopping criterion for group flux during outer/power iteration \\ \hline
    \verb"maxinner" & Integer & - & Maximum number of inner iterations \\ \hline
    \verb"maxouter" & Integer & - & Maximum number of outer/power iterations \\ \hline
    \verb"jfnk_krsze" & Integer & - & Maximum size of Krylov subspace during jfnk \\ \hline
    \verb"jfnk_maxkr" &Integer & - & Maximum number of Krylov iterations\\ \hline
    \verb"jfnk_method" & String & outer / flat / flat\_wds & Type of jfnk formulation, see~\cite{}\\ \hline
    \verb"initial_guess" & String & yes / no & If an initial guess file should be read\\ \hline
    \verb"restart_out" & String & yes / no & If a restart file should be written \\ \hline
    \verb"ipiter" & Integer & - & Number of initial power iterations for jfnk\\ \hline
    \verb"print_conv" & String & yes / no & If convergence monitor is written to file \verb"thor.convergence"\\ \hline
    \verb"density_factor" & String & no / byvolume / fromfile  & Density factor options: use no density factors (no), use density factors and density factor file provides region volumes (byvolume), use density factors and density factor file provides density factors (fromfile). \\ \hline
    \verb"execution" & String & yes / no & If yes problem is executed, if no then input is only read and checked.\\ \hline
    \verb"mesh"&String& -& Name of the mesh file\\ \hline
    \verb"source"&String& -& Name of the volumetric source file\\ \hline
    \verb"flux_out"&String& -& Name of the THOR formatted output flux file\\ \hline
    \verb"xs"&String& -& Name of the cross section file\\ \hline
    \verb"vtk_flux_out"&String& -& Name of the vtk flux file\\ \hline
    \verb"vtk_mat_out"&String& -& Name of the vtk material file\\ \hline
    \verb"vtk_reg_out"&String& -& Name of the vtk region file\\ \hline
    \verb"vtk_src_out"&String& -& Name of the vtk volumetric source file\\ \hline
    \verb"cartesian_map_out"&&&Name of the file that the cartesian map output is written to\\ \hline
    \verb"print_xs"&String& yes / no& If cross sections are echoed to standard output.\\ \hline
    \verb"ngroups"&Integer& -& Number of energy groups\\ \hline
    \verb"pnorder"&Integer& -& Spherical harmonics order used for scattering in code\\ \hline
    \verb"pnread"&Integer& -& Spherical harmonics expansion provided in cross section file\\ \hline
    \verb"upscattering" & String & yes / no & Read upscattering data from cross section file or ignore it \\ \hline
    \verb"multiplying" & String & yes / no & If the cross section file contains fission information \\ \hline
    \verb"scatt_mult_included" & String & yes /no & If the scattering data includes the $2 l + 1$ multiplier or not \\ \hline
    \verb"qdtype" & String & levelsym / legcheb / fromfile & Quadrature type: level-symmetric, Legendre-Chebyshev, read from file \\ \hline
    \verb"qdorder" & Integer & - & Order of the angular quadrature \\ \hline
    \verb"cartesian_map" & Real (9 entries) & - & xmin, xmax, nx, ymin, ymax, ny, zmin, zmax, nz \\ \hline
    \verb"point_value_locations" & Real (3 N) & - & N is the number of points, (x,y,z) coordinates of N points, x1 y1 z1 x2 y2 ...  \\ \hline
    \verb"region_map" & Real (3 N) & - & N is the number of points, (x,y,z) coordinates of N points, x1 y1 z1 x2 y2 ...  \\
    \bottomrule
\end{longtable}

The blocks are:
\begin{itemize}
    \item The first line must contain a user selected name for the problem.
    \item \verb"problem": general parameters to define the problem to be solved
    \item \verb"inout": Names of inputs and outputs files and toggles for specific output.
    \item \verb"cross_sections": parameters pertaining to the cross section data.
    \item \verb"quadrature": parameters pertaining to the angular quadrature.
    \item \verb"postprocess": parameters pertaining to postprocessing outputs. \verb"cartesian_map" sets up an overlayed Cartesian mesh that fluxes and reactions rates are averaged over. The Cartesian mesh is defined by the minimum and maximum coordinates for each direction (x, y, z) and number of subdivisions between. \verb"point_value_locations" allows extraction of flux values at user provided points.
    \item \verb"regionmap": mapping from region id to cross section id. Region ids are an integer assigned to to each tetrahedral element that are used to group elements into regions or blocks (see Sect.~\ref{sec:mesh_format}). Cross section ids are indices that identify sets of cross sections provided in the cross section input file (see Sect.~\ref{sec:cross_section_format}).
\end{itemize}

Blocks are delineated with \verb"start" and \verb"end" keywords like this:
\begin{verbatim}
    start <block_name>
       key1 = value1 ; key2 = value2
       key3 = value3
    end <block_name>
\end{verbatim}
Each blocks contains several keyword-value pairs. Multiply assignments can be placed on the same
line if they are separated by \verb";".
The keyword-value pairs can be provided in an arbitrary order.
All keywords are listed in Table~\ref{tab:thor_solver_parameters}.

\begin{table}[p]
    \centering
    \caption{Keywords of THOR Transport Solver Application\label{tab:thor_solver_parameters_2}}
    \begin{tabular}{l l l l}
        \toprule
        Keyword & Type & Options & Explanation\\
        \midrule
        \multicolumn{4}{l}{\textbf{Block}: inout}\\
        \bottomrule
    \end{tabular}
\end{table}

The \verb"regionmap" block does not contain keyword-value pairs. Instead, it maps region ids to cross section ids. We denote by
\verb"min_reg" and \verb"max_reg" the smallest and largest region ids in the mesh file. The number of entries in the \verb"regionmap"
field must then be \verb"num_entries" = \verb"max_reg" - \verb"min_reg" + 1. The assignment is best illustrated for an example.
Let us assume that \verb"min_reg" = -1 and \verb"max_reg" = 2 and we want to assign
\begin{verbatim}
    -1 -> 12
     0 -> 1
     1 -> 1
     2 -> 3
\end{verbatim}
Then the \verb"regionmap" block is given by:
\begin{verbatim}
start regionmap
 12 1 1 3
end regionmap
\end{verbatim}
Unused region ids can be accommodated by padding the entries in the regionmap field.

\section{THOR Mesh Format}\label{ch:inp:sec:meshfile}
Line 1: number of vertices
\vspace{2mm}

\noindent Line 2: number of elements
\vspace{2mm}

\noindent Line 3: unused enter 1
\vspace{2mm}

\noindent Line 4: unused enter 1
\vspace{2mm}

\noindent Block 1: vertex coordinates, number of lines = number of vertices; each line is as follows: vertex\_id (integer) x-coordinate (Real) y-coordinate (Real) z-coordinate (Real)
\vspace{2mm}

\noindent Block 2: region and source id assignments, number of lines = number of elements; each line is as follows: element\_id region\_id source\_id (all integers). For setting up Monte Carlo on the tet mesh, this block can be ignored.
\vspace{2mm}

\noindent Block 3: element descriptions, the vertex\_ids that form each element. Number of lines = number of elements; each line is as follows: element\_id vertex\_id1 vertex\_id2 vertex\_id3 vertex\_id4 (all integers).
\vspace{2mm}

\noindent Next line: number of boundary face edits
\vspace{2mm}

\noindent Block 4: boundary face descriptions. All exterior faces associated with their boundary condition id, number if lines = number of boundary face edits; each line is as follows: element\_id local\_tetrahedron\_face\_id boundary\_condition\_id.
\vspace{2mm}

\noindent \textbf{Explanation}:
local\_tetrahedron\_face\_id: natural local id of tetrahedron’s face which is the id of the vertex opposite to this face. Note: indexed 0-3.
boundary\_condition\_id:
value = 0: vacuum BC
value = 1: reflective BC
value = 2: fixed inflow
\vspace{2mm}

\noindent Next line: number of adjacency list entries
\vspace{2mm}

\noindent Block 5: adjacency list, number of lines = number of adjacency list entries; each line is as follows: element\_id face\_id neighbor\_id neighbor\_face\_id.
Explanation: The element\_id is the current element. The neighbor across the face indexed by face\_id has the element id neighbor\_id and the its own local index for the said common face is neighbor\_face\_id.

\section{THOR Cross Section Format}\label{ch:inp:sec:xsfile}
\begin{verbatim}
Line 1: number of materials

Block 1: each entry in this block contains cross sections for a single material. Each entry contains  L *G+ 6 lines.

Entry line 1: material_id
Entry line 2: fission_spectrum_1 fission_spectrum_2 … fission_spectrum_G
Entry line 3: energy_group_boundary_1 energy_group_boundary_3 … energy_group_boundary_G
Entry line 4: fission_xs_1 fission_xs_2 fission_xs_3 … fission_xs_G
Entry line 5: nu_bar_1 nu_bar_2 … nu_bar_G
Entry line 6: total_xs_1 total_xs_2 … total_xs_G
Entry line 7: sig_scat_{0, 1->1} sig_scat_{0, 2->1} … sig_scat_{0, G->1}
Entry line 8: sig_scat_{0, 1->2} sig_scat_{0, 2->2} … sig_scat_{0, G->2}

        :
Entry line G + 6: sig_scat_{0, 1->G} sig_scat_{0, 2->G} … sig_scat_{0, G->G}
Entry line G + 7: sig_scat_{1, 1->1} sig_scat_{1, 2->1} … sig_scat_{1, G->1}
Entry line G + 8: sig_scat_{1, 1->2} sig_scat_{1, 2->2} … sig_scat_{1, G->2}

        :
Entry line 2 * G + 6: sig_scat_{1, 1->G} sig_scat_{1, 2->G} … sig_scat_{1, G->G}
        :

\end{verbatim}

\begin{itemize}
\item G = total number of groups.
\item L = scattering expansion.
\item fission\_spectrum\_g: fraction of neutrons born in fission that appear in energy group g.
\item energy\_group\_boundary\_g: currently unused, can be filled with 0s. Upper bound of energy group g.
\item fission\_xs\_g: fission cross section (NOTE: not nu\_bar * fission\_xs) in group g.
\item nu\_bar\_g: average number of neutrons released by fission caused by a neutron in energy group g.
\item total\_xs\_g: total cross section in energy group g.
\item sig\_scat\_{l, g’->g}: l-th Legendre polynomial moment of the scattering cross section from group g’ to g. The (2 * l + 1) factor may be included in the value of the cross section or not, THOR can handle both cases. It needs to be specified separately every time.
\end{itemize}



\section{List of all Inputs and Outputs of THOR transport solver}

\section{THOR Mesh Generator}
This section discusses the input of THOR's mesh generator tool. The mesh generator tool provides the following capabilties:
\begin{itemize}
    \item Convert exodus~\cite{exodus_format} formatted meshes to THOR format.
    \item Convert gmsh~\cite{gmsh_ref} formatted meshes to THOR format.
    \item Convert universal file format meshes to THOR format.
    \item Split the elements of hexahedra and wedge (triangular prisms) meshes into tetrahedra before comverting to THOR mesh format.
    \item Conversion of legacy THOR mesh format to new format.
\end{itemize}

\subsection{Compilation and Invocation}
Navigate to:
\begin{verbatim}
    >> cd /home/<usr>/projects/THOR/pre-processors/THOR_Mesh_Generator/src
\end{verbatim}
and make the application:
\begin{verbatim}
    >> make
\end{verbatim}
The executable \verb"Thor_Mesh_Generator.exe" should have been created here:
\begin{verbatim}
    >> /home/<usr>/projects/THOR/pre-processors/THOR_Mesh_Generator/Thor_Mesh_Generator.exe
\end{verbatim}
The application is invoked with:
\begin{verbatim}
    >> /path/to/Thor_Mesh_Generator.exe -i standard_input
\end{verbatim}
where \verb"standard_input" is the standard input file.

\noindent\textbf{Remark:} Conversion of exodus files to gmsh files relies on using libMesh's \verb"mesh-tool"~\cite{libMeshPaper}. You must compile libMesh and set the environment variable \verb"THOR_LIBMESH_DIRECTORY".

\subsection{Format of the THOR's mesh generator standard input}
The standard input file of the THOR mesh generator contains the following lines:
\begin{verbatim}
input_mesh_file
output_mesh_file
region_id_file
source_id_file
boundary_id_file
\end{verbatim}
where \verb"input_mesh_file" and \verb"output_mesh_file" are required parameters, while the remaining parameters are optional.
If a parameter is omitted, the line should just be left blank (that means that e.g. \verb"source_id_file" will always be provided
on line 4 regardless of whether \verb"region_id_file" was provided).

The purpose of these files is as follows:
\begin{itemize}
    \item \verb"input_mesh_file": name of the input mesh file. Note that the file ending matters: exodus is \verb".e" and gmsh is \verb".msh", because the mesh format is inferred from it.
    \item \verb"output_mesh_file": name of the THOR mesh format files. Use file ending \verb".thrm".
    \item  \verb"region_id_file": name of file that contains instructions to reassign region (sometimes called block) ids. Formatting instructions for this file is provided in Sect.~\ref{sec:reassign_file_format}.
    \item  \verb"source_id_file": name of file that contains instructions to reassign source ids. Formatting instructions for this file is provided in Sect.~\ref{sec:reassign_file_format}.
    \item  \verb"boundary_id_file": name of file that contains instructions to reassign boundary ids. Formatting instructions for this file is provided in Sect.~\ref{sec:reassign_file_format}.
\end{itemize}

\subsection{Formatting instructions for regions, source, and boundary id reassignment files}\label{sec:reassign_file_format}
IDs are integers that are assigned to each tetrahedral element to group it into a region, a source region or assigned to boundary
faces to group it into a set of faces for boundary assignment.
The file format for id reassignment files is:
\begin{verbatim}
n
old_id_<1> new_id_<1>
  :
  :
old_id_<n> new_id_<n>
\end{verbatim}
The meaning is as follows:
\begin{itemize}
    \item \verb"n": the number of instructions in the file (i.e. the number of lines following this line).
    \item \verb"old_id_<j>": the j-th old id that will be replaced by \verb"new_id_<j>".
    \item \verb"new_id_<j>": the j-th new id that will replace \verb"old_id_<j>"
\end{itemize}
\textbf{Remarks:}
\begin{itemize}
    \item Note, each instruction needs to be on a different line.
    \item The boundary id characterizes the boundary condition. It must be 0, 1, or 2, where 0 is a vacuum, 1 is a reflective, and 2 is a fixed inflow boundary.
\end{itemize}

\section{Testing}
THOR provides a convenient test harness that can be executed by the user by navigating to the \verb"scripts" directory that exists as subdirectory for all applications; for example, for the THOR transport solver the test file is located in:
\begin{verbatim}
    >> /home/<usr>/projects/THOR/THOR/scripts
\end{verbatim}
The tests are executed via the \verb"run_thor_tests.py" python script. The execution of the python script requires \textit{python3}. Tests are executed by:
\begin{verbatim}
    >> cd /home/<usr>/projects/THOR/THOR/scripts
    >> python run_thor_tests.py
\end{verbatim}
The output of the test script should look like this:
\begin{verbatim}
-------------------------------------
Test  1 name success
  :
Test  N name success
-------------------------------------
Successes:  N            Failures:  0
\end{verbatim}